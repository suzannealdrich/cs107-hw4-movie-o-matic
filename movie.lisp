;; This line just tells LISP where to place the symbols in this module;; (packages are ways of breaking up the namespace).  This says to;; consider symbols in this package to be part of the CL user space(in-package "COMMON-LISP-USER");; PRINT-ELEMENTS;; --------------;; Helper function for "print-nicely" that prints the elements of the;; given list on separate lines. (defun print-elements (list)  (if (null list) '()    (progn      (print (car list))      (print-elements (cdr list)))));; PRINT-NICELY;; ------------;; Prints the list "list" with each element on a separate line.;; This function isn't really "functional" since its interesting;; output is essentially a side-effect to the console. It returns NIL;; because it needs to return something.  The read-eval-print loop;; in the Lisp interpreter will print out the NIL return value;; following the nice print out of the list. This may or may not;; be useful for you, you decide whether it's worth using.(defun print-nicely (list)  (if (not (listp list))    (error "Function print-nicely received something other than a list")    (progn      (princ "(")      (print-elements list)      (terpri)      (princ ")")      (terpri)      (terpri)      nil)));; ACCESSOR FUNCTIONS;; ------------------;; Use these to obtain the different components of the movie records in;; the database, much preferable to a lot of nested car/cdr action ;; everywhere in your code.  We encourage small functions with good names, ;; this can really improve the readability of your code, something LISP isn't;; all that strong in.(defun name (list)  ;; can be used on both person and movie entries to get name  (car list))(defun ratings-list (profile)  ;; grabs the list of movie ratings from a person's profile  (second profile))(defun rating (movie-list)  ;; given a movie entry, pulls out the numerical rating  (second movie-list))(defun comments (movie-list)  ;; given a movie entry, pulls out the comments  (third movie-list));; LOOK;; ----;; given a predicate function and a list, it returns the first matching element(defun look (fnp lst)  (if (null lst) '()    (if (funcall fnp (car lst))      (car lst)      (look fnp (cdr lst)))))            ;; MOST;; ----;; given a list and a comparison function, it returns the greatest element(defun most (lst fncmp)  (if (null lst) '()    (if (null (cdr lst)) (car lst)      (let ((mostofrest (most (cdr lst) fncmp)))        (if (funcall fncmp (car lst) mostofrest)           (car lst) mostofrest)))));; FILTER-OUT;; ----------;; given a predicate function and a list, it strips the list of all matching elements(defun filter-out (fnp lst)  (if (null lst) '()    (if (funcall fnp (car lst))       (filter-out fnp (cdr lst))      (cons (car lst) (filter-out fnp (cdr lst))))))            ;; PROFILE;; -------;; given a person string and database symbol, it returns their profile list(defun profile (person database)  (look #'(lambda (entry) (string= person (name entry))) database))  ;; POLL-REVIEWERS;; --------------;; given a movie string and database symbol, it returns an unsorted list of;; all reviews of the movie(defun poll-reviewers (movie database)  (if (null database) '()    (let ((review (first (filter-out #'(lambda (moviereview)      (string/= movie (name moviereview))) (ratings-list (car database))))))       (append (if (null review) '() (list (cons (name (car database)) (cdr review))))         (poll-reviewers movie (cdr database))))));; BETTER-MOVIE;; ------------;; given two movie reviews, it returns true if first is rated better than second(defun better-movie (moviereview1 moviereview2)  (> (rating moviereview1) (rating moviereview2)))  ;; TRIM-FLOAT;; ----------;; given a number, it returns a float trimmed to two decimal digits(defun trim-float (number)  (float (/ (round (* 100 number)) 100)))    ;; RATINGS;; -------;; given a movie string and a database symbol, it returns a list of ;; the average rating and the sorted reviews of the movie(defun ratings (movie database)  (let ((reviews (sort (poll-reviewers movie database) #'better-movie)))    (if (null reviews) '()      (list movie (trim-float (/ (apply #'+ (mapcar #'rating reviews)) (length reviews))) reviews))));; MOVIES;; ------;; given a profile list, it returns a list of the names of movies reviewed(defun movies (profile)  (mapcar #'name (ratings-list profile)))  ;; ALL-MOVIES;; ----------;; given a database symbol, it returns a list of the names of all movies reviewed(defun all-movies (database)  (if (null database) '()    (union (movies (car database)) (all-movies (cdr database)) :test #'string=)));; ALL-RATINGS;; -----------;; given a database symbol, it returns a sorted list of ratings for all movies reviewed(defun all-ratings (database) (print-nicely  (sort (mapcar #'(lambda (movie) (ratings movie database)) (all-movies database)) #'better-movie)));; COMPATIBILITY;; -------------;; given a match (reviewer ((movie rating rating) (...))), ;; it returns the compatibility index over all ratings pairs in the movie matches(defun compatibility (match)  (float (* 10 (/ (apply #'+    (mapcar #'(lambda (moviematch) (- 10 (abs (- (second moviematch) (third moviematch))))) (second match)))      (length (second match))))));; RATE-MOVIE;; ----------;; given a movie string, a person string, and a database symbol, ;; it returns the person's numerical rating of the movie(defun rate-movie (movie person database)  (rating (look #'(lambda (moviereview)    (string= movie (name moviereview))) (ratings-list (profile person database)))))    ;; COMMON-RATINGS;; --------------;; given a match (reviewer (movie movie ...)), a person string, and a database symbol,;; it returns a match (reviewer ((movie rating rating) (...)))(defun common-ratings (match person database)  (mapcar #'(lambda (movie)    (list movie (rate-movie movie person database) (rate-movie movie (first match) database)))    (second match)))    ;; COMMON-MOVIES;; -------------;; given two profile lists, it returns a list of the movies they have in common(defun common-movies (profile1 profile2)  (intersection (movies profile1) (movies profile2) :test #'string=))  ;; FIND-MATCHES;; -----------;; given a person string and a database symbol, it returns a match database;; of the form ((reviewer (movie movie ...)) (...)) containing only movies;; in common with person, whose entry has been removed(defun find-matches (person database)  (filter-out #'(lambda (entry) (null (second entry)))     (mapcar #'(lambda (entry) (list (name entry) (common-movies entry (profile person database))))       (filter-out #'(lambda (entry) (string= person (name entry))) database))))        ;; RATE-MATCHES;; ------------;; given a person string and a database symbol, it returns an augmented match database ;; of the form ((compatibility reviewer ((movie rating rating) (...))) (...)) (defun rate-matches (person database)  (mapcar #'(lambda (match) (list (compatibility match) (first match) (second match)))    (mapcar #'(lambda (match) (list (first match) (common-ratings match person database)))       (find-matches person database))));; BETTER-MATCH;; ------------;; given two matches, it returns true if first is more compatible than second(defun better-match (match1 match2)  (> (first match1) (first match2)));; BEST-BUDDY;; ----------;; given a person string and a database symbol, it returns the most compatible match(defun best-buddy (person database)  (let ((bestbuddy (most (rate-matches person database) #'better-match)))    (if (null (first bestbuddy)) '()       (list person (trim-float (first bestbuddy)) '% 'COMPATIBLE 'WITH (second bestbuddy)        (list (length (third bestbuddy)) 'MATCHES (third bestbuddy)))))) ;; UNSEEN-MOVIES;; -------------;; given a match and a database symbol, it returns a list of reviews ;; by the match reviewer of movies that aren't in the match(defun unseen-movies (match database)  (set-difference (ratings-list (profile (second match) database)) (third match) :key #'name :test #'string=));; RECOMMEND-FOR;; -------------;; given a person string, a minimum compatibility and rating, and a database symbol, it returns;; a sorted list of reviews by compatible reviewers of good movies not seen by the person (defun recommend-for (person mincompat minrating database)  (let ((goodbuddies (filter-out #'(lambda (match) (> mincompat (first match)))     (sort (rate-matches person database) #'better-match))))  (if (null goodbuddies) '() (print-nicely     (mapcar #'(lambda (match) (list (second match) (trim-float (first match)) '% 'RECOMMENDS      (filter-out #'(lambda (moviereview) (> minrating (rating moviereview)))         (sort (unseen-movies match database) #'better-movie)))) goodbuddies)))))